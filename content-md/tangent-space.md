# Bumpmapping: A Journey into Tangent Space

I recently worked on creating a simple 3D engine, and one of the features I wanted to implement was *bumpmapping*. For those who don't know, bumpmapping is a technique for making flat surfaces appear to have some sort of depth texture (called a heightmap), by performing the lighting calculations with the normal of the heightmap rather than the normal of the actual surface. You aren't changing the geometry, the surface is actually flat, but the lighting allows small divets and surface-level features to *appear* present. 

The normal vector of a plane in 3D is a vector that is orthogonal (perpendicular) to every vector on the plane. By plane, I really mean plane passing through the origin, as we're going to treat them independent of position. Normal vectors point directly away from a plane, and we can easily compute them for a triangle $\{a, b, c\}$. First, we pick $c$ to use as our "origin". We then have $a - c$ and $b - c$ as vectors that lie on the plane defined by our triangle. Taking the cross product gives a vector orthogonal to both of them. The normal is, as the name would suggest, this vector normalized. 

It's fairly obvious that this works, and playing around with it will clearly give the normal vector if you implement and play around with it a little. However, we're going to go deeper, and try to actually think about why this is orthogonal to *every* vector on the triangle. This auxillary, seemingly unnecessary insight gives rise to a very important idea. 

The trick here is that $a - c$ and $b - c$ form a *basis*, and the plane we've defined is the *subspace* spanned by that basis. If you aren't familiar with the idea of a basis, the important part is that every vector on the plane can be expressed as some linear combination of the basis vectors $a - c$ and $b - c$. Mathematically, any point $\vec{p}$ is on the plane if and only if $\vec{p} = \alpha (a - c) + \beta (b - c)$ for some $\alpha$ and some $\beta$. We say that the set $\{a - c, b - c\}$ *spans* the plane. Now, we can use a much more general fact: if a vector $\vec{v}$ is orthogonal to a set of vectors $S$, then it's also orthogonal to any element $\vec{w}$ of the span of $S$. 

If we scale a vector $\vec{w}$, which is orthogonal to $\vec{v}$, $\vec{w}$ also orthogonal to it. This follows from the dot product $\vec{v} \cdot \vec{w} = \sum_i v_i w_i = 0$. The $k$ term can simply be pulled out of the summation, and $k 0 = 0$. Additionally, if we add a two vectors $\vec{a}$ and $\vec{b}$, both orthogonal to $\vec{v}$, then $\vec{a} + \vec{b}$ is also orthogonal to $\vec{v}$. Here, we get $\sum_i v_i (a_i + b_i) = \left( \sum_i v_i a_i \right) + \left( \sum_i v_i b_i \right)$. The two addends here are the dot products $\vec{v} \cdot \vec{a}$ and $\vec{v} \cdot \vec{b}$, both of which are zero. 

Returning to graphics, for a point light, the key factor here is that lighting is primarily dependent on two vectors (other than materials, the type of light source, and other things that remain constant):
+ The vector from the light source to the object. Because this is only changed negligably by the kinds of small perturbations bumpmapping is used to model, we can just do this as if the surface was flat. 
+ The normal vector of the surface. Instead of getting the normal vector of a flat plane, we're going to get this part from the heightmap. 

The heightmap is, however, a surface and not a plane. However, we only care about what the surface looks like at a single point. The core idea here is one familiar to anyone who has taken calculus: *local linearity*. The simplest version is that as you zoom in on a (differentiable) function $y = f(x)$, it approaches a line, with a slope corresponding to the derivative $\frac{dy}{dx}$ at that point. We can generalize this to arbitrary surfaces. As you zoom in on differentiable manifold (in $n$ dimensions), it approaches an $n$-dimensional hyperplane. A hyperplane is just a subspace. We call the subspace a manifold approaches at a point its *tangent space*. 

Now, we can look at a completely different interpretation of derivatives. A tiny change $dx$ results in a tiny change $dy$, and the ratio between them is the derivative $\frac{dy}{dx}$. This is exactly what would happen if the function were a line with slope $\frac{dy}{dx}$, and the function approaches that line as the distances we consider become smaller and smaller. We're going to focus more on the previous interpretation, but thinking of differentials as their own entities is very important. 

Now, we'll consider a 2D surface in 3D space, defined by the constraints $z = f(x, y)$. Here, $f$ is essentially the heightmap in function form. We now need to find two basis vectors of the tangent space. The basis vector in the $x$ direction can be broken into a tiny change $\partial x$, a corresponding tiny change $\partial z$, and no $y$ component. We can write this as $\begin{bmatrix}\partial x & 0 & \partial z\end{bmatrix}$. The same exact process in the $y$ direction gives $\begin{bmatrix}0 & \partial y & \partial z\end{bmatrix}$. As useful as differentials are, we can only actually calculate derivatives. Since scaling vectors has no effect on their span, we'll multiply the first basis vector by $(\partial x)^{-1}$ and the second basis vector by $(\partial y)^{-1}$. This gives the calculable basis vectors $\begin{bmatrix}1 & 0 & \frac{\partial z}{\partial x}\end{bmatrix}$ and $\begin{bmatrix}0 & 1 & \frac{\partial z}{\partial y}\end{bmatrix}$. We found the tangent space! 

That's all there is too it. If you have a parametric surface already defined as a function, you can substitute in the appropriate partial derivatives. If you have more complex heightmap, you can approximate them with finite differences. Taking the cross product of the basis vectors of the tangent space and normalizing it gives you the normal of the surface at a point, so all that we have to do is convert from the coordinate space of the surface to the coordinate space your lighting engine is working with. A positive $z$ needs to represent outwards instead of up, but that's just a change of basis matrix that you have to provide. 
